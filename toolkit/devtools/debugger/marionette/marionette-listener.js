marionetteTimeout = null;

/* TODO: handle WebElements */
//also, take a look at http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/utils.js?r=11715
function unwrapArgs(args, doc) {
  var ret = [];
  while(args && args.length > 0) {
    var check = args.shift;
    if (typeof check == "object") {
    }
  }
}

/* function to set the timeout of asynchronous scripts */
function setScriptTimeout(msg) {
  marionetteTimeout= parseInt(msg.json.value);
  if(isNaN(marionetteTimeout)){
     var error = { message: "Not a Number", stacktrace: null };
     sendAsyncMessage("Marionette:error", {type:"setScriptTimeout", error: error});
  } else {
     sendAsyncMessage("Marionette:done", {type:"setScriptTimeout", ok: "ok"});
  }
}

/* send error when we detect an unload event during async scripts */
function errUnload() {
  var error = { message: "unload was called", status: 17, stacktrace: null };
  sendAsyncMessage("Marionette:error", {type:"executeAsyncScript", error: error});
}

/* upon completion or error from the async script, send response to marionette-responder */
function asyncResponse() {
  var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']  
                          .getService(Components.interfaces.nsIWindowMediator);  
  var browser = WindowMediator.getMostRecentWindow('navigator:browser');
  browser.window.removeEventListener("unload", errUnload, false);
  browser.window.removeEventListener("marionette-async-response", asyncResponse, false);

  /* clear all timeouts potentially generated by the script*/
  var maxTimeoutId = browser.document.getUserData('__marionetteTimeoutId');
  for(var i=0; i<=maxTimeoutId; i++) {
    browser.window.clearTimeout(i);
  }

  var res = browser.document.getUserData('__marionetteRes');
  var session = browser.document.getUserData('__marionetteSession');
  var type = 'executeAsyncScript';
  if (res.status == 0){
    sendAsyncMessage("Marionette:done", {type: type, session: session, value: res.value, status: res.status});
  } else {
    var error = { status: res.status, message: res.value, stacktrace: null };
    sendAsyncMessage("Marionette:error", {type:type, session: session, error: error});
  }
}

function executeAsyncScript(msg) {
  var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']  
                          .getService(Components.interfaces.nsIWindowMediator);  
  var browser = WindowMediator.getMostRecentWindow('navigator:browser');
  browser.window.addEventListener("unload", errUnload, false);
  browser.window.addEventListener("marionette-async-response", asyncResponse, false);
  var doc = browser.document;
  var body = browser.document.body;
  var script = msg.json.value;
  var args = msg.json.args ? msg.json.args : []; //TODO: handle WebElement JSON Objects

  /* the function to return values/error from sandbox by triggering an event we listen for */
  //TODO: do we reset timeout?
  var asyncComplete = 
  "function(value, status) { " + 
   "var __marionetteRes = document.getUserData('__marionetteRes');" +
   "if(__marionetteRes.status == undefined) { " +
   " __marionetteRes.value = value; " +
   " __marionetteRes.status = status; " +
   " document.setUserData('__marionetteRes', __marionetteRes, null); " +
   " var ev = document.createEvent('Events'); " +
   " ev.initEvent('marionette-async-response', true, false); "+
   " document.dispatchEvent(ev);" +
   "} " +
  "}"

  var window = browser;
  var sandbox = new Components.utils.Sandbox(window);
  sandbox.window = window;
  sandbox.document = doc;
  sandbox.timeoutId = null;
  sandbox.navigator = window.navigator;
  sandbox.__marionetteParams = args;
  sandbox.document.setUserData("__marionetteRes", {}, null);
  sandbox.document.setUserData("__marionetteSession", msg.json.session, null);
  //TODO: odd. error code 28 is scriptTimeout, but spec says executeAsync should return code 21: Timeout...
  //and selenium code returns 28 (http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/evaluate.js)
  var scriptSrc = "with(window) {" +
                  "var asyncComplete = " + asyncComplete + " ; " +
                  "var callback = function(value) { return asyncComplete(value,0);};" +
                  "__marionetteParams.push(callback);" +
                  "var __marionetteFunc = function() { " + script +
                  "};  __marionetteFunc.apply(null, __marionetteParams); " +
                  "var timeoutId = window.setTimeout(asyncComplete," +
                   marionetteTimeout +  ", 'timed out', 28);" +
                  "window.document.setUserData('__marionetteTimeoutId', timeoutId, null);}";
  try {
    Components.utils.evalInSandbox(scriptSrc, sandbox);
   } catch (e) {
      var type = "executeAsyncScript";
      var session = msg.json.session;
     //TODO: check the error status and if there is a stacktrace.
     var error = { status: 500, message: e, stacktrace: null };
     sendAsyncMessage("Marionette:error", {type:type, session: session, error: error});
   }
}

function executeScript(msg) {
  /* get the currently opened window */
  var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']  
                          .getService(Components.interfaces.nsIWindowMediator);  
  var browser = WindowMediator.getMostRecentWindow('navigator:browser');
  var doc = browser.document;

  var script = msg.json.value;
  var args = msg.json.args; //TODO: handle WebElement JSON Objects


  var window = browser;
  var sandbox = new Components.utils.Sandbox(window);
  sandbox.window = window;
  sandbox.document = doc;
  sandbox.navigator = window.navigator;
  sandbox.__marionetteParams = args;
  var scriptSrc = "with(window) { var __marionetteFunc = function(){" + script +
                  "};  __marionetteFunc.apply(null, __marionetteParams); }";
  var type = "executeScript";
  var session = msg.json.session;
  try {
     var res = Components.utils.evalInSandbox(scriptSrc, sandbox);
     sendAsyncMessage("Marionette:done", {type: type, session: session, value: res});
   } catch (e) {
     //TODO: check the error status and if there is a stacktrace.
     var error = { status: 500, message: e, stacktrace: null };
     sendAsyncMessage("Marionette:error", {type:type, session: session, error: error});
   }
 }

addMessageListener("Marionette:executeScript", executeScript);
addMessageListener("Marionette:executeAsyncScript", executeAsyncScript);
addMessageListener("Marionette:setScriptTimeout", setScriptTimeout);

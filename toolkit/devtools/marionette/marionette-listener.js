/* we only need one instance of each listener running in content space */
var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                     .getService(Components.interfaces.nsIPrefBranch);
if (!prefs.getBoolPref("marionette.contentListener")) {
  var marionetteTimeout = null;
  var marionetteTimer = null; //nsITimer instance for timing async chrome scripts
  var curWindow = null; //holds the current window
  var curContext = "content"; //holds the current context
  prefs.setBoolPref("marionette.contentListener", true);
  addMessageListener("Marionette:setContext", setContext);
  addMessageListener("Marionette:executeScript", executeScript);
  addMessageListener("Marionette:setScriptTimeout", setScriptTimeout);
  addMessageListener("Marionette:executeAsyncScript", executeAsyncScript);
}

/*
function newSession() {
  //getCurrentWindow();
  curContext = content;
  sendAsyncMessage("Marionette:done", {type:"newSession", value: 'mobile'});
}
*/

/*
 * Helper methods 
 */ 
function getCurrentWindow() {
  if (curWindow == null) {
    var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']  
                            .getService(Components.interfaces.nsIWindowMediator);  
    var win = WindowMediator.getMostRecentWindow('navigator:browser');
    curWindow = win;
  }
}

/* TODO: handle WebElements */
//also, take a look at http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/utils.js?r=11715
function unwrapArgs(args, doc) {
  var ret = [];
  while(args && args.length > 0) {
    var check = args.shift;
    if (typeof check == "object") {
    }
  }
}

/* send error when we detect an unload event during async scripts */
function errUnload() {
  var error = { message: "unload was called", status: 17, stacktrace: null };
  sendAsyncMessage("Marionette:error", {error: error});
}

/* upon completion or error from the async script, send response to marionette-responder */
function asyncResponse() {
  getCurrentWindow();
  curWindow.window.removeEventListener("unload", errUnload, false);
  curWindow.window.document.removeEventListener("marionette-async-response", asyncResponse, false);

  /* clear all timeouts potentially generated by the script*/
  var maxTimeoutId = curWindow.document.getUserData('__marionetteTimeoutId');
  for(var i=0; i<=maxTimeoutId; i++) {
    curWindow.window.clearTimeout(i);
  }

  var res = curWindow.document.getUserData('__marionetteRes');
  var session = curWindow.document.getUserData('__marionetteSession');
 // var type = 'executeAsyncScript';
  if (res.status == 0){
    sendAsyncMessage("Marionette:done", {session: session, value: res.value, status: res.status});
  }
  else {
    var error = { status: res.status, message: res.value, stacktrace: null };
    sendAsyncMessage("Marionette:error", {session: session, error: error});
  }
}

/*
 * Marionette Methods
 */

/* set the context of the subsequent calls to either 'chrome' or 'content' */
function setContext(msg) {
  curContext = msg.json.value;
  sendAsyncMessage("Marionette:ok", {});
}

/* execute given script in the current context */
function executeScript(msg) {
  /* get the currently opened window */
  getCurrentWindow();
  if (curContext == "chrome") {
    try {
      var params = msg.json.args;
      var script = "var func = function() {" + msg.json.value + "}; func.apply(null, params);";
      var res = eval(script);
      sendAsyncMessage("Marionette:done", {session: msg.json.session, value: res});
    }
    catch (e) {
      var error = { status: null, message: e, stacktrace: null };
      sendAsyncMessage("Marionette:error", {session: msg.json.session, error: error});
    }
  }
  else {
    var doc = curWindow.document;
  
    var script = msg.json.value;
    var args = msg.json.args; //TODO: handle WebElement JSON Objects
  
    var window = curWindow;
    var sandbox = new Components.utils.Sandbox(window);
    sandbox.window = window;
    sandbox.document = doc;
    sandbox.navigator = window.navigator;
    sandbox.__marionetteParams = args;
    var scriptSrc = "with(window) { var __marionetteFunc = function(){" + script +
                    "};  __marionetteFunc.apply(null, __marionetteParams); }";
    //var type = "executeScript";
    var session = msg.json.session;
    try {
       var res = Components.utils.evalInSandbox(scriptSrc, sandbox);
       sendAsyncMessage("Marionette:done", {session: session, value: res});
     } catch (e) {
       //TODO: check the error status and if there is a stacktrace.
       var error = { status: 500, message: e, stacktrace: null };
       sendAsyncMessage("Marionette:error", { session: session, error: error});
     }
   }
 }

/* function to set the timeout of asynchronous scripts */
function setScriptTimeout(msg) {
  marionetteTimeout= parseInt(msg.json.value);
  if(isNaN(marionetteTimeout)){
    var error = { message: "Not a Number", stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
  else {
    sendAsyncMessage("Marionette:ok", {});
  }
}

/* execute given asynchronous script in the current context */
function executeAsyncScript(msg) {
  getCurrentWindow();
  curWindow.window.addEventListener("unload", errUnload, false);
  curWindow.window.document.addEventListener("marionette-async-response", asyncResponse, false);
  var doc = curWindow.document;
  var body = curWindow.document.body;
  var script = msg.json.value;
  var args = msg.json.args ? msg.json.args : []; //TODO: handle WebElement JSON Objects

  /* the function to return values/error from sandbox by triggering an event we listen for */
  //TODO: do we reset timeout?
  var asyncComplete = 
  "function(value, status) { " + 
   "var __marionetteRes = document.getUserData('__marionetteRes');" +
   "if(__marionetteRes.status == undefined) { " +
   " __marionetteRes.value = value; " +
   " __marionetteRes.status = status; " +
   " document.setUserData('__marionetteRes', __marionetteRes, null); " +
   " var ev = document.createEvent('Events'); " +
   " ev.initEvent('marionette-async-response', true, false); "+
   " document.dispatchEvent(ev);" +
   "} " +
  "}"

  var window = curWindow;
  var sandbox = new Components.utils.Sandbox(window);
  sandbox.window = window;
  sandbox.document = doc;
  sandbox.timeoutId = null;
  sandbox.navigator = window.navigator;
  sandbox.__marionetteParams = args;
  sandbox.document.setUserData("__marionetteRes", {}, null);
  sandbox.document.setUserData("__marionetteSession", msg.json.session, null);
  //TODO: odd. error code 28 is scriptTimeout, but spec says executeAsync should return code 21: Timeout...
  //and selenium code returns 28 (http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/evaluate.js)
  var scriptSrc = "with(window) {" +
                  "var asyncComplete = " + asyncComplete + " ; " +
                  "var callback = function(value) { return asyncComplete(value,0);};" +
                  "__marionetteParams.push(callback);" +
                  "var __marionetteFunc = function() { " + script +
                  "};  __marionetteFunc.apply(null, __marionetteParams); " +
                  "var timeoutId = window.setTimeout(asyncComplete," +
                   marionetteTimeout +  ", 'timed out', 28);" +
                  "window.document.setUserData('__marionetteTimeoutId', timeoutId, null);}";
  try {
   Components.utils.evalInSandbox(scriptSrc, sandbox);
  } catch (e) {
    //var type = "executeAsyncScript";
    var session = msg.json.session;
    //TODO: check the error status and if there is a stacktrace.
    var error = { status: null, message: e, stacktrace: null };
    sendAsyncMessage("Marionette:error", {session: session, error: error});
  }
}

function clickElement(msg) {
  var element = curWindow.document.getElementById(msg.json.element);
  if (element == null) {
    var error = {};
    var error = { message: "Element not in DOM", stacktrace: null, status: 10};
    sendAsyncMessage("Marionette:error", {error: error});
  }
  /* reset current window in case we went to a new tab */
  curWindow = null;
  getCurrentWindow();
}

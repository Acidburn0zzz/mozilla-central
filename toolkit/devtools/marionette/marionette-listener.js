/* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 *   Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2011
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *    Malini Das (mdas@mozilla.com)
 *    Jonathan Griffin (jgriffin@mozilla.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

var Ci = Components.interfaces;
var Cc = Components.classes;
var Cu = Components.utils;

var isB2G = false;

var marionetteTimeout = null;
var marionetteTimer = null; //nsITimer instance for timing async chrome scripts
var curWindow = null; //holds the current window
var curContext = "content"; //holds the current context
addMessageListener("Marionette:newSession", newSession);
addMessageListener("Marionette:setContext", setContext);
addMessageListener("Marionette:executeScript", executeScript);
addMessageListener("Marionette:setScriptTimeout", setScriptTimeout);
addMessageListener("Marionette:executeAsyncScript", executeAsyncScript);

function newSession(msg) {
  isB2G = msg.json.B2G;
  resetValues();
  getCurrentWindow();
  sendAsyncMessage("Marionette:done", {value: 'mobile'});
}

/*
 * Helper methods 
 */ 

function resetValues() {
  marionetteTimeout = null;
  marionetteTimer = null; //nsITimer instance for timing async chrome scripts
  curWindow = null; //holds the current window
  curContext = "content"; //holds the current context
}

function getCurrentWindow() {
  if (curWindow == null) {
    var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']
                            .getService(Components.interfaces.nsIWindowMediator);
    if (isB2G) {
      var win = WindowMediator.getMostRecentWindow(null);
    }
    else {
      var win = WindowMediator.getMostRecentWindow('navigator:browser');
    }
    curWindow = win;
  }
}

/* TODO: handle WebElements */
//also, take a look at http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/utils.js?r=11715
function unwrapArgs(args, doc) {
  var ret = [];
  while(args && args.length > 0) {
    var check = args.shift;
    if (typeof check == "object") {
    }
  }
}

/* send error when we detect an unload event during async scripts */
function errUnload() {
  var error = { message: "unload was called", status: 17, stacktrace: null };
  sendAsyncMessage("Marionette:error", {error: error});
}

/* upon completion or error from the async script, send response to marionette-responder */
function asyncResponse() {
  getCurrentWindow();
  var window = content;
  window.window.removeEventListener("unload", errUnload, false);
  window.document.removeEventListener("marionette-async-response", asyncResponse, false);

  /* clear all timeouts potentially generated by the script*/
  var maxTimeoutId = window.document.getUserData('__marionetteTimeoutId');
  for(var i=0; i<=maxTimeoutId; i++) {
    window.clearTimeout(i);
  }

  var res = window.document.getUserData('__marionetteRes');
  // var type = 'executeAsyncScript';
  if (res.status == 0){
    sendAsyncMessage("Marionette:done", {value: res.value, status: res.status});
  }
  else {
    //return the error that happened during execution
    var error = { status: res.status, message: res.value, stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
}

/* gets responses from async chrome scripts */
function chromeAsyncResponse(value, status) {
  if (status != undefined && marionetteTimer !=null) {
    //we have timed out
    var error = { status: status, message: value, stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
    marionetteTimer = null;
  }
  else if (marionetteTimer != null) {
    //then the timer has not been fired and the call completed within time allotted
    marionetteTimer.cancel();
    marionetteTimer = null;
    sendAsyncMessage("Marionette:done", {value: value});
  }
}

/*
 * Marionette Methods
 */

/* set the context of the subsequent calls to either 'chrome' or 'content' */
function setContext(msg) {
  var context = msg.json.value;
  if (context != "chrome" && context != "content") {
    var error = { status: null, message: "context must either be 'chrome' or 'content'", stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
  else {
    curContext = msg.json.value;
    sendAsyncMessage("Marionette:ok", {});
  }
}

/* execute given script in the current context */
function executeScript(msg) {
  /* get the currently opened window */
  getCurrentWindow();
  if (curContext == "chrome") {
    try {
      var params = msg.json.args;
      var _chromeSandbox = new Cu.Sandbox(curWindow,
         { sandboxPrototype: curWindow, wantXrays: false, 
           sandboxName: ''});
      _chromeSandbox.__marionetteParams = params;
      var script = "var func = function() {" + msg.json.value + "}; func.apply(null, __marionetteParams);";
      var res = Cu.evalInSandbox(script, _chromeSandbox);
      sendAsyncMessage("Marionette:done", {value: res});
    }
    catch (e) {
      // 17 = JavascriptException
      var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
      sendAsyncMessage("Marionette:error", {error: error});
    }
  }
  else {
    var script = msg.json.value;
    var args = msg.json.args; //TODO: handle WebElement JSON Objects

    var sandbox = new Cu.Sandbox(content);
    sandbox.window = content;
    sandbox.document = sandbox.window.document;
    sandbox.navigator = sandbox.window.navigator;
    sandbox.__marionetteParams = args;
    sandbox.__proto__ = sandbox.window;
    var scriptSrc = "with (window) { var __marionetteFunc = function(){" + script +
                    "};  __marionetteFunc.apply(null, __marionetteParams); }";
    try {
      var res = Cu.evalInSandbox(scriptSrc, sandbox);
      sendAsyncMessage("Marionette:done", {value: res});
    } catch (e) {
      // 17 = JavascriptException
      var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
      sendAsyncMessage("Marionette:error", { error: error});
    }
  }
}

/* function to set the timeout of asynchronous scripts */
function setScriptTimeout(msg) {
  marionetteTimeout = parseInt(msg.json.value);
  if(isNaN(marionetteTimeout)){
    var error = { message: "Not a Number", stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
  else {
    sendAsyncMessage("Marionette:ok", {});
  }
}

/* execute given asynchronous script in the current context */
function executeAsyncScript(msg) {
  getCurrentWindow();
  if (curContext == "chrome") {
    marionetteTimer = Components.classes["@mozilla.org/timer;1"]
                .createInstance(Components.interfaces.nsITimer);
    var params = msg.json.args;
    var _chromeSandbox = new Cu.Sandbox(curWindow,
       { sandboxPrototype: curWindow, wantXrays: false, 
         sandboxName: ''});
    var marionetteScriptFinished = chromeAsyncResponse;
    var marionetteTimeoutCallback = {
                                       notify: function() {
                                         marionetteScriptFinished('timed out', 28);
                                       }
                                     };
    params.push(marionetteScriptFinished);
    _chromeSandbox.sendAsyncMessage = sendAsyncMessage;
    _chromeSandbox.__marionetteParams = params;
    _chromeSandbox.marionetteScriptFinished = marionetteScriptFinished;
    _chromeSandbox.__marionetteTimeoutCallback = marionetteTimeoutCallback;
    _chromeSandbox.marionetteTimer = marionetteTimer;
    var script = "var __marionetteFunc = function() {" + msg.json.value + "};" +
                 "__marionetteFunc.apply(null, __marionetteParams);" + 
                 "marionetteTimer.initWithCallback(__marionetteTimeoutCallback," + marionetteTimeout +
                 ",Components.interfaces.nsITimer.TYPE_ONE_SHOT);";

    Components.utils.evalInSandbox(script, _chromeSandbox);
  }
  else {
    content.addEventListener("unload", errUnload, false);
    content.document.addEventListener("marionette-async-response", asyncResponse, false);

    var script = msg.json.value;
    var args = msg.json.args ? msg.json.args : []; //TODO: handle WebElement JSON Objects
  
    /* the function to return values/error from sandbox by triggering an event we listen for */
    var asyncComplete = 
    "function(value, status) { " + 
     "var __marionetteRes = document.getUserData('__marionetteRes');" +
     "if(__marionetteRes.status == undefined) { " +
     " __marionetteRes.value = value; " +
     " __marionetteRes.status = status; " +
     " document.setUserData('__marionetteRes', __marionetteRes, null); " +
     " var ev = document.createEvent('Events'); " +
     " ev.initEvent('marionette-async-response', true, false); "+
     " document.dispatchEvent(ev);" +
     "} " +
    "}"

    var sandbox = new Cu.Sandbox(content);
    sandbox.window = content;
    sandbox.document = sandbox.window.document;
    sandbox.timeoutId = null;
    sandbox.navigator = sandbox.window.navigator;
    sandbox.__marionetteParams = args;
    sandbox.document.setUserData("__marionetteRes", {}, null);
    sandbox.__proto__ = sandbox.window;
    //TODO: odd. error code 28 is scriptTimeout, but spec says executeAsync should return code 21: Timeout...
    //and selenium code returns 28 (http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/evaluate.js)
    var scriptSrc = "with(window) {" +
                    "var asyncComplete = " + asyncComplete + " ; " +
                    "var marionetteScriptFinished = function(value) { return asyncComplete(value,0);};" +
                    "__marionetteParams.push(marionetteScriptFinished);" +
                    "var __marionetteFunc = function() { " + script +
                    "};  __marionetteFunc.apply(null, __marionetteParams); " +
                    "var timeoutId = window.setTimeout(asyncComplete," +
                     marionetteTimeout +  ", 'timed out', 28);" +
                    "window.document.setUserData('__marionetteTimeoutId', timeoutId, null);}";
    try {
     Cu.evalInSandbox(scriptSrc, sandbox);
    } catch (e) {
      // 17 = JavascriptException
      var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
      sendAsyncMessage("Marionette:error", {error: error});
    }
  }
}

function clickElement(msg) {
  var element = curWindow.document.getElementById(msg.json.element);
  if (element == null) {
    var error = {};
    var error = { message: "Element not in DOM", stacktrace: null, status: 10};
    sendAsyncMessage("Marionette:error", {error: error});
  }
  /* reset current window in case we went to a new tab */
  curWindow = null;
  getCurrentWindow();
}

/* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 *   Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2011
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/* we only need one instance of each listener running in content space */
var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                     .getService(Components.interfaces.nsIPrefBranch);
if (!prefs.getBoolPref("marionette.contentListener")) {
  var marionetteTimeout = null;
  var marionetteTimer = null; //nsITimer instance for timing async chrome scripts
  var curWindow = null; //holds the current window
  var curContext = "content"; //holds the current context
  prefs.setBoolPref("marionette.contentListener", true);
  addMessageListener("Marionette:newSession", newSession);
  addMessageListener("Marionette:setContext", setContext);
  addMessageListener("Marionette:executeScript", executeScript);
  addMessageListener("Marionette:setScriptTimeout", setScriptTimeout);
  addMessageListener("Marionette:executeAsyncScript", executeAsyncScript);
  addMessageListener("Marionette:goUrl", goUrl);
}

function newSession() {
  resetValues();
  getCurrentWindow();
  sendAsyncMessage("Marionette:done", {value: 'mobile'});
}

/*
 * Helper methods 
 */ 

function resetValues() {
  marionetteTimeout = null;
  marionetteTimer = null; //nsITimer instance for timing async chrome scripts
  curWindow = null; //holds the current window
  curContext = "content"; //holds the current context
}

function getCurrentWindow() {
  if (curWindow == null) {
    var WindowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1']  
                            .getService(Components.interfaces.nsIWindowMediator);  
    var win = WindowMediator.getMostRecentWindow('navigator:browser');
    curWindow = win;
  }
}

/* TODO: handle WebElements */
//also, take a look at http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/utils.js?r=11715
function unwrapArgs(args, doc) {
  var ret = [];
  while(args && args.length > 0) {
    var check = args.shift;
    if (typeof check == "object") {
    }
  }
}

/* send error when we detect an unload event during async scripts */
function errUnload() {
  var error = { message: "unload was called", status: 17, stacktrace: null };
  sendAsyncMessage("Marionette:error", {error: error});
}

/* upon completion or error from the async script, send response to marionette-responder */
function asyncResponse() {
  getCurrentWindow();
  curWindow.window.removeEventListener("unload", errUnload, false);
  curWindow.window.document.removeEventListener("marionette-async-response", asyncResponse, false);

  /* clear all timeouts potentially generated by the script*/
  var maxTimeoutId = curWindow.document.getUserData('__marionetteTimeoutId');
  for(var i=0; i<=maxTimeoutId; i++) {
    curWindow.window.clearTimeout(i);
  }

  var res = curWindow.document.getUserData('__marionetteRes');
 // var type = 'executeAsyncScript';
  if (res.status == 0){
    sendAsyncMessage("Marionette:done", {value: res.value, status: res.status});
  }
  else {
    var error = { status: res.status, message: res.value, stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
}

/*
 * Marionette Methods
 */

/* set the context of the subsequent calls to either 'chrome' or 'content' */
function setContext(msg) {
  curContext = msg.json.value;
  sendAsyncMessage("Marionette:ok", {});
}

/* execute given script in the current context */
function executeScript(msg) {
  /* get the currently opened window */
  getCurrentWindow();
  if (curContext == "chrome") {
    try {
      var params = msg.json.args;
      var script = "var func = function() {" + msg.json.value + "}; func.apply(null, params);";
      var res = eval(script);
      sendAsyncMessage("Marionette:done", {value: res});
    }
    catch (e) {
      // 17 = JavascriptException
      var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
      sendAsyncMessage("Marionette:error", {error: error});
    }
  }
  else {
    var doc = curWindow.document;
  
    var script = msg.json.value;
    var args = msg.json.args; //TODO: handle WebElement JSON Objects
  
    var window = curWindow;
    var sandbox = new Components.utils.Sandbox(window);
    sandbox.window = window;
    sandbox.document = doc;
    sandbox.navigator = window.navigator;
    sandbox.__marionetteParams = args;
    var scriptSrc = "with(window) { var __marionetteFunc = function(){" + script +
                    "};  __marionetteFunc.apply(null, __marionetteParams); }";
    //var type = "executeScript";
    try {
       var res = Components.utils.evalInSandbox(scriptSrc, sandbox);
       sendAsyncMessage("Marionette:done", {value: res});
     } catch (e) {
       //TODO: check the error status and if there is a stacktrace.
       // 17 = JavascriptException
       var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
       sendAsyncMessage("Marionette:error", { error: error});
     }
   }
 }

/* function to set the timeout of asynchronous scripts */
function setScriptTimeout(msg) {
  marionetteTimeout= parseInt(msg.json.value);
  if(isNaN(marionetteTimeout)){
    var error = { message: "Not a Number", stacktrace: null };
    sendAsyncMessage("Marionette:error", {error: error});
  }
  else {
    sendAsyncMessage("Marionette:ok", {});
  }
}

/* execute given asynchronous script in the current context */
function executeAsyncScript(msg) {
  getCurrentWindow();
  //TODO: make this work
  if (curContext == "chrome") {
    var marionetteTimer = Components.classes["@mozilla.org/timer;1"]
                .createInstance(Components.interfaces.nsITimer);
    
    var params = msg.json.args;
    var script = "var func = function() {" + msg.json.value + "}; func.apply(null, params);";
    var runScript = {
      run: function() {
      while(true){dump("asdf");}
      }
    }
    dump("MDAS: Running script in thread\n");
    var thread = Components.classes["@mozilla.org/thread-manager;1"]
                           .getService(Components.interfaces.nsIThreadManager)
                             .newThread(0)
    thread.dispatch(runScript, Components.interfaces.nsIThread.DISPATCH_NORMAL);
    dump("MDAS: dispatched\n");
    //marionetteTimer.initWithCallback(function() { thread.shutdown(); } , marionetteTimeout, 1000);

  }
  else {
    curWindow.window.addEventListener("unload", errUnload, false);
    curWindow.window.document.addEventListener("marionette-async-response", asyncResponse, false);
    var doc = curWindow.document;
    var body = curWindow.document.body;
    var script = msg.json.value;
    var args = msg.json.args ? msg.json.args : []; //TODO: handle WebElement JSON Objects
  
    /* the function to return values/error from sandbox by triggering an event we listen for */
    var asyncComplete = 
    "function(value, status) { " + 
     "var __marionetteRes = document.getUserData('__marionetteRes');" +
     "if(__marionetteRes.status == undefined) { " +
     " __marionetteRes.value = value; " +
     " __marionetteRes.status = status; " +
     " document.setUserData('__marionetteRes', __marionetteRes, null); " +
     " var ev = document.createEvent('Events'); " +
     " ev.initEvent('marionette-async-response', true, false); "+
     " document.dispatchEvent(ev);" +
     "} " +
    "}"
  
    var window = curWindow;
    var sandbox = new Components.utils.Sandbox(window);
    sandbox.window = window;
    sandbox.document = doc;
    sandbox.timeoutId = null;
    sandbox.navigator = window.navigator;
    sandbox.__marionetteParams = args;
    sandbox.document.setUserData("__marionetteRes", {}, null);
    //TODO: odd. error code 28 is scriptTimeout, but spec says executeAsync should return code 21: Timeout...
    //and selenium code returns 28 (http://code.google.com/p/selenium/source/browse/trunk/javascript/firefox-driver/js/evaluate.js)
    var scriptSrc = "with(window) {" +
                    "var asyncComplete = " + asyncComplete + " ; " +
                    "var callback = function(value) { return asyncComplete(value,0);};" +
                    "__marionetteParams.push(callback);" +
                    "var __marionetteFunc = function() { " + script +
                    "};  __marionetteFunc.apply(null, __marionetteParams); " +
                    "var timeoutId = window.setTimeout(asyncComplete," +
                     marionetteTimeout +  ", 'timed out', 28);" +
                    "window.document.setUserData('__marionetteTimeoutId', timeoutId, null);}";
    try {
     Components.utils.evalInSandbox(scriptSrc, sandbox);
    } catch (e) {
      //var type = "executeAsyncScript";
      //TODO: check the error status and if there is a stacktrace.
      // 17 = JavascriptException
      var error = { status: 17, message: e.name + ': ' + e.message, stacktrace: null };
      sendAsyncMessage("Marionette:error", {error: error});
    }
  }
}

function goUrl(msg) {
  curWindow.window.location.href = msg.json.value;
  sendAsyncMessage("Marionette:ok", {});
}

function clickElement(msg) {
  var element = curWindow.document.getElementById(msg.json.element);
  if (element == null) {
    var error = {};
    var error = { message: "Element not in DOM", stacktrace: null, status: 10};
    sendAsyncMessage("Marionette:error", {error: error});
  }
  /* reset current window in case we went to a new tab */
  curWindow = null;
  getCurrentWindow();
}
